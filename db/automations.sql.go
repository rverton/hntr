// Code generated by sqlc. DO NOT EDIT.
// source: automations.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createAutomation = `-- name: CreateAutomation :one
INSERT INTO automations (
    name, description, box_id, command, source_container, source_tags, destination_container, destination_tags, is_public
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, name, description, box_id, command, source_container, source_tags, destination_container, destination_tags, is_public, created_at
`

type CreateAutomationParams struct {
	Name                 string    `json:"name"`
	Description          string    `json:"description"`
	BoxID                uuid.UUID `json:"box_id"`
	Command              string    `json:"command"`
	SourceContainer      string    `json:"source_container"`
	SourceTags           []string  `json:"source_tags"`
	DestinationContainer string    `json:"destination_container"`
	DestinationTags      []string  `json:"destination_tags"`
	IsPublic             bool      `json:"is_public"`
}

func (q *Queries) CreateAutomation(ctx context.Context, arg CreateAutomationParams) (Automation, error) {
	row := q.db.QueryRow(ctx, createAutomation,
		arg.Name,
		arg.Description,
		arg.BoxID,
		arg.Command,
		arg.SourceContainer,
		arg.SourceTags,
		arg.DestinationContainer,
		arg.DestinationTags,
		arg.IsPublic,
	)
	var i Automation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BoxID,
		&i.Command,
		&i.SourceContainer,
		&i.SourceTags,
		&i.DestinationContainer,
		&i.DestinationTags,
		&i.IsPublic,
		&i.CreatedAt,
	)
	return i, err
}

const createAutomationEvent = `-- name: CreateAutomationEvent :one
INSERT INTO automation_events (
    box_id, automation_id, data, status, affected_rows
) VALUES ($1, $2, $3, $4, $5) RETURNING id, box_id, automation_id, status, data, affected_rows, created_at, finished_at
`

type CreateAutomationEventParams struct {
	BoxID        uuid.UUID `json:"box_id"`
	AutomationID uuid.UUID `json:"automation_id"`
	Data         string    `json:"data"`
	Status       string    `json:"status"`
	AffectedRows int32     `json:"affected_rows"`
}

func (q *Queries) CreateAutomationEvent(ctx context.Context, arg CreateAutomationEventParams) (AutomationEvent, error) {
	row := q.db.QueryRow(ctx, createAutomationEvent,
		arg.BoxID,
		arg.AutomationID,
		arg.Data,
		arg.Status,
		arg.AffectedRows,
	)
	var i AutomationEvent
	err := row.Scan(
		&i.ID,
		&i.BoxID,
		&i.AutomationID,
		&i.Status,
		&i.Data,
		&i.AffectedRows,
		&i.CreatedAt,
		&i.FinishedAt,
	)
	return i, err
}

const deleteAutomation = `-- name: DeleteAutomation :exec
DELETE FROM automations WHERE id = $1
`

func (q *Queries) DeleteAutomation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAutomation, id)
	return err
}

const getAutomation = `-- name: GetAutomation :one
SELECT id, name, description, box_id, command, source_container, source_tags, destination_container, destination_tags, is_public, created_at FROM automations WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAutomation(ctx context.Context, id uuid.UUID) (Automation, error) {
	row := q.db.QueryRow(ctx, getAutomation, id)
	var i Automation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BoxID,
		&i.Command,
		&i.SourceContainer,
		&i.SourceTags,
		&i.DestinationContainer,
		&i.DestinationTags,
		&i.IsPublic,
		&i.CreatedAt,
	)
	return i, err
}

const listAutomationEvents = `-- name: ListAutomationEvents :many
SELECT id, box_id, automation_id, status, data, affected_rows, created_at, finished_at FROM automation_events WHERE automation_id = $1 ORDER BY created_at DESC LIMIT $2
`

type ListAutomationEventsParams struct {
	AutomationID uuid.UUID `json:"automation_id"`
	Limit        int32     `json:"limit"`
}

func (q *Queries) ListAutomationEvents(ctx context.Context, arg ListAutomationEventsParams) ([]AutomationEvent, error) {
	rows, err := q.db.Query(ctx, listAutomationEvents, arg.AutomationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationEvent{}
	for rows.Next() {
		var i AutomationEvent
		if err := rows.Scan(
			&i.ID,
			&i.BoxID,
			&i.AutomationID,
			&i.Status,
			&i.Data,
			&i.AffectedRows,
			&i.CreatedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAutomationLibrary = `-- name: ListAutomationLibrary :many
SELECT 
    id, name, description, command, source_container, source_tags, destination_container, destination_tags, is_public
FROM automations
WHERE is_public = true
`

type ListAutomationLibraryRow struct {
	ID                   uuid.UUID `json:"id"`
	Name                 string    `json:"name"`
	Description          string    `json:"description"`
	Command              string    `json:"command"`
	SourceContainer      string    `json:"source_container"`
	SourceTags           []string  `json:"source_tags"`
	DestinationContainer string    `json:"destination_container"`
	DestinationTags      []string  `json:"destination_tags"`
	IsPublic             bool      `json:"is_public"`
}

func (q *Queries) ListAutomationLibrary(ctx context.Context) ([]ListAutomationLibraryRow, error) {
	rows, err := q.db.Query(ctx, listAutomationLibrary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAutomationLibraryRow{}
	for rows.Next() {
		var i ListAutomationLibraryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Command,
			&i.SourceContainer,
			&i.SourceTags,
			&i.DestinationContainer,
			&i.DestinationTags,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAutomations = `-- name: ListAutomations :many
SELECT id, name, description, box_id, command, source_container, source_tags, destination_container, destination_tags, is_public, created_at FROM automations WHERE box_id = $1
`

func (q *Queries) ListAutomations(ctx context.Context, boxID uuid.UUID) ([]Automation, error) {
	rows, err := q.db.Query(ctx, listAutomations, boxID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Automation{}
	for rows.Next() {
		var i Automation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BoxID,
			&i.Command,
			&i.SourceContainer,
			&i.SourceTags,
			&i.DestinationContainer,
			&i.DestinationTags,
			&i.IsPublic,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAutomationEventStatus = `-- name: UpdateAutomationEventStatus :exec
UPDATE automation_events SET status = $1 where id = $2
`

type UpdateAutomationEventStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAutomationEventStatus(ctx context.Context, arg UpdateAutomationEventStatusParams) error {
	_, err := q.db.Exec(ctx, updateAutomationEventStatus, arg.Status, arg.ID)
	return err
}

const updateAutomationEventStatusFinished = `-- name: UpdateAutomationEventStatusFinished :exec
UPDATE automation_events SET status = $1, affected_rows = $2, finished_at = now() where id = $3
`

type UpdateAutomationEventStatusFinishedParams struct {
	Status       string    `json:"status"`
	AffectedRows int32     `json:"affected_rows"`
	ID           uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAutomationEventStatusFinished(ctx context.Context, arg UpdateAutomationEventStatusFinishedParams) error {
	_, err := q.db.Exec(ctx, updateAutomationEventStatusFinished, arg.Status, arg.AffectedRows, arg.ID)
	return err
}
